#!/usr/bin/env bash
set -e

# gh-switch - GitHub Account Switcher
# Version 1.0.0

# === Configuration ===
VERSION="1.0.0"
GH_SWITCH_DIR="${HOME}/.config/gh-switch"
PROFILES_DIR="${GH_SWITCH_DIR}/profiles"
CONFIG_FILE="${GH_SWITCH_DIR}/config"
SSH_CONFIG="${HOME}/.ssh/config"

# === Colors ===
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

# === Common Functions ===
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }

ensure_config_dir() {
    mkdir -p "${GH_SWITCH_DIR}"
    mkdir -p "${PROFILES_DIR}"
}

# === Profile Functions ===
create_profile() {
    local name="$1" ssh_key="$2" git_name="$3" git_email="$4" github_user="$5"
    local gpg_key_id="${6:-}" gpg_sign_commits="${7:-false}"
    cat > "${PROFILES_DIR}/${name}" <<EOF
SSH_KEY="${ssh_key}"
GIT_NAME="${git_name}"
GIT_EMAIL="${git_email}"
GITHUB_USER="${github_user}"
HOST_ALIAS="github.com-${name}"
GPG_KEY_ID="${gpg_key_id}"
GPG_SIGN_COMMITS="${gpg_sign_commits}"
EOF
    log_success "Profile '${name}' created"
}

load_profile() {
    local name="$1"
    local profile_file="${PROFILES_DIR}/${name}"
    if [[ -f "${profile_file}" ]]; then
        source "${profile_file}"
        # Set defaults for backward compatibility
        GPG_KEY_ID="${GPG_KEY_ID:-}"
        GPG_SIGN_COMMITS="${GPG_SIGN_COMMITS:-false}"
        return 0
    fi
    return 1
}

# === SSH Functions ===
ssh_host_exists() {
    grep -q "^Host ${1}$" "${SSH_CONFIG}" 2>/dev/null
}

backup_ssh_config() {
    cp "${SSH_CONFIG}" "${SSH_CONFIG}.gh-switch.backup"
    log_info "SSH config backed up"
}

add_ssh_host() {
    local name="$1" ssh_key="$2" host_alias="github.com-${name}"

    if ssh_host_exists "${host_alias}"; then
        log_info "SSH host ${host_alias} already exists"
        return 0
    fi

    cat >> "${SSH_CONFIG}" <<EOF

# GitHub account: ${name}
Host ${host_alias}
  HostName github.com
  User git
  IdentityFile ${ssh_key}
  IdentitiesOnly yes
EOF
    log_success "Added SSH host ${host_alias}"
}

remove_ssh_host() {
    local host="$1"
    sed -i.bak "/^Host ${host}$/,/^$/d" "${SSH_CONFIG}"
}

# === Git Config Functions ===
get_git_config() {
    local key="$1" scope="${2:-local}"
    [[ "$scope" == "local" ]] && ! git rev-parse --git-dir &>/dev/null && return 1
    git config --${scope} --get "${key}" 2>/dev/null
}

set_git_config() {
    local key="$1" value="$2" scope="${3:-local}"
    if [[ "$scope" == "local" ]] && ! git rev-parse --git-dir &>/dev/null; then
        log_error "Not in a git repository"
        return 1
    fi
    git config --${scope} "${key}" "${value}"
}

apply_git_profile() {
    set_git_config "user.name" "${1}" "${3:-local}"
    set_git_config "user.email" "${2}" "${3:-local}"
}

apply_git_gpg_config() {
    local gpg_key_id="$1" gpg_sign_commits="$2" scope="${3:-local}"
    if [[ -n "$gpg_key_id" ]]; then
        set_git_config "user.signingkey" "${gpg_key_id}" "${scope}"
        log_info "Set GPG signing key: ${gpg_key_id}"
        if [[ "$gpg_sign_commits" == "true" ]]; then
            set_git_config "commit.gpgsign" "true" "${scope}"
            log_info "Enabled automatic GPG commit signing"
        else
            set_git_config "commit.gpgsign" "false" "${scope}"
        fi
    else
        if [[ "$scope" == "local" ]] && git rev-parse --git-dir &>/dev/null; then
            git config --${scope} --unset user.signingkey 2>/dev/null || true
            git config --${scope} --unset commit.gpgsign 2>/dev/null || true
        elif [[ "$scope" == "global" ]]; then
            git config --${scope} --unset user.signingkey 2>/dev/null || true
            git config --${scope} --unset commit.gpgsign 2>/dev/null || true
        fi
    fi
}

update_remote_url() {
    local profile="$1"
    local current_url=$(git remote get-url origin 2>/dev/null)
    if [[ -n "$current_url" ]]; then
        local new_url=$(echo "$current_url" | sed "s/github\.com[-a-z]*/github.com-${profile}/")
        git remote set-url origin "$new_url"
        log_info "Updated origin URL to use ${profile} profile"
    fi
}

# === GPG Functions ===
check_gpg_installed() {
    command -v gpg &>/dev/null || command -v gpg2 &>/dev/null
}

get_gpg_cmd() {
    command -v gpg2 &>/dev/null && echo "gpg2" || command -v gpg &>/dev/null && echo "gpg" || echo ""
}

list_gpg_keys() {
    local gpg_cmd=$(get_gpg_cmd)
    [[ -z "$gpg_cmd" ]] && log_error "GPG is not installed" && return 1
    echo "Available GPG keys:"
    echo "==================="
    $gpg_cmd --list-secret-keys --keyid-format LONG 2>/dev/null | grep -E "^(sec|uid)" | sed 's/^/  /'
    echo ""
    echo "Hint: Use the key ID after 'sec' (e.g., 'rsa4096/ABCD1234EFGH5678')"
    echo "      Extract just the ID part: ABCD1234EFGH5678"
}

validate_gpg_key() {
    local key_id="$1" gpg_cmd=$(get_gpg_cmd)
    [[ -z "$gpg_cmd" ]] && log_error "GPG is not installed" && return 1
    [[ -z "$key_id" ]] && return 0
    $gpg_cmd --list-secret-keys "$key_id" &>/dev/null || (log_error "GPG key '$key_id' not found in keyring" && return 1)
}

select_gpg_key_interactive() {
    local gpg_cmd=$(get_gpg_cmd)
    [[ -z "$gpg_cmd" ]] && log_info "GPG is not installed. Skipping GPG key setup." && echo "" && return 0
    ! $gpg_cmd --list-secret-keys &>/dev/null && log_info "No GPG keys found in keyring. Skipping GPG key setup." && echo "" && return 0
    echo ""
    list_gpg_keys
    local gpg_key=""
    read -p "GPG key ID (optional, press Enter to skip): " gpg_key
    if [[ -n "$gpg_key" ]]; then
        validate_gpg_key "$gpg_key" && echo "$gpg_key" && return 0
        log_error "Invalid GPG key. Profile will be created without GPG signing."
        echo ""
        return 1
    fi
    echo ""
    return 0
}

# === Shell Detection Functions ===
detect_shell() {
    # Check parent process
    local parent_cmd=$(ps -o comm= -p $PPID 2>/dev/null)
    
    # Try to determine shell from parent process
    if [[ "$parent_cmd" == *"zsh"* ]]; then
        echo "zsh"
    elif [[ "$parent_cmd" == *"bash"* ]]; then
        echo "bash"
    # Check SHELL environment variable as fallback
    elif [[ "$SHELL" == *"zsh"* ]]; then
        echo "zsh"
    elif [[ "$SHELL" == *"bash"* ]]; then
        echo "bash"
    else
        echo "unknown"
    fi
}

install_completions() {
    local shell_type=$(detect_shell)
    
    log_info "Detected shell: $shell_type"
    
    case "$shell_type" in
        bash)
            install_bash_completions
            ;;
        zsh)
            install_zsh_completions
            ;;
        unknown)
            log_info "Could not detect shell type. Skipping completion installation."
            log_info "Completions can be manually installed later."
            return 1
            ;;
    esac
}

install_bash_completions() {
    local bash_completion_content='#!/usr/bin/env bash

_gh_switch() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Main commands
    opts="init add use current list delete auto help"

    case "${prev}" in
        gh-switch)
            COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
            return 0
            ;;
        use|delete)
            # Complete with profile names
            local profiles=""
            if [[ -d "$HOME/.config/gh-switch/profiles" ]]; then
                profiles=$(ls "$HOME/.config/gh-switch/profiles" 2>/dev/null)
            fi
            COMPREPLY=( $(compgen -W "${profiles}" -- ${cur}) )
            return 0
            ;;
    esac
}

complete -F _gh_switch gh-switch'

    # Try different bash completion directories
    local bash_comp_dirs=(
        "/etc/bash_completion.d"
        "/usr/local/etc/bash_completion.d"
        "$HOME/.bash_completion.d"
    )
    
    for dir in "${bash_comp_dirs[@]}"; do
        if [[ -d "$dir" ]] && [[ -w "$dir" ]]; then
            echo "$bash_completion_content" > "$dir/gh-switch"
            log_success "Bash completions installed to $dir/gh-switch"
            return 0
        elif [[ -d "$dir" ]]; then
            # Directory exists but not writable, try with sudo
            if echo "$bash_completion_content" | sudo tee "$dir/gh-switch" >/dev/null 2>&1; then
                log_success "Bash completions installed to $dir/gh-switch (with sudo)"
                return 0
            fi
        fi
    done
    
    # Fallback: create user-level completion directory
    local user_comp_dir="$HOME/.bash_completion.d"
    mkdir -p "$user_comp_dir"
    echo "$bash_completion_content" > "$user_comp_dir/gh-switch"
    log_success "Bash completions installed to $user_comp_dir/gh-switch"
    log_info "Add this to your ~/.bashrc: source $user_comp_dir/gh-switch"
    return 0
}

install_zsh_completions() {
    local zsh_completion_content='#compdef gh-switch

_gh_switch() {
    local commands profiles

    commands=(
        "init:Initialize gh-switch"
        "add:Add a new profile"
        "use:Switch to a profile"
        "current:Show current profile"
        "list:List all profiles"
        "delete:Delete a profile"
        "auto:Auto-detect profile"
        "help:Show help"
    )

    case $state in
        args)
            case $words[2] in
                use|delete)
                    profiles=(${(f)"$(ls ~/.config/gh-switch/profiles 2>/dev/null)"})
                    _arguments "*:profile:($profiles)"
                    ;;
                *)
                    _describe "command" commands
                    ;;
            esac
            ;;
    esac
}

_gh_switch "$@"'

    # Try different zsh completion directories
    local zsh_comp_dirs=(
        "/usr/local/share/zsh/site-functions"
        "/usr/share/zsh/site-functions"
        "$HOME/.zsh/completions"
    )
    
    for dir in "${zsh_comp_dirs[@]}"; do
        if [[ -d "$dir" ]] && [[ -w "$dir" ]]; then
            echo "$zsh_completion_content" > "$dir/_gh-switch"
            log_success "Zsh completions installed to $dir/_gh-switch"
            return 0
        elif [[ -d "$dir" ]]; then
            # Directory exists but not writable, try with sudo
            if echo "$zsh_completion_content" | sudo tee "$dir/_gh-switch" >/dev/null 2>&1; then
                log_success "Zsh completions installed to $dir/_gh-switch (with sudo)"
                return 0
            fi
        fi
    done
    
    # Fallback: create user-level completion directory
    local user_comp_dir="$HOME/.zsh/completions"
    mkdir -p "$user_comp_dir"
    echo "$zsh_completion_content" > "$user_comp_dir/_gh-switch"
    log_success "Zsh completions installed to $user_comp_dir/_gh-switch"
    log_info "Add this to your ~/.zshrc: fpath=($user_comp_dir \$fpath)"
    log_info "Then run: autoload -Uz compinit && compinit"
    return 0
}

# === Commands ===
cmd_init() {
    echo "Initializing gh-switch..."
    ensure_config_dir

    [[ ! -f "${CONFIG_FILE}" ]] && cat > "${CONFIG_FILE}" <<EOF
VERSION=1.0.0
AUTO_DETECT=true
DEFAULT_PROFILE=
EOF

    [[ ! -d "$HOME/.ssh" ]] && mkdir -p "$HOME/.ssh" && chmod 700 "$HOME/.ssh"
    [[ ! -f "${SSH_CONFIG}" ]] && touch "${SSH_CONFIG}" && chmod 600 "${SSH_CONFIG}"

    backup_ssh_config
    log_success "gh-switch initialized!"
    echo ""
    
    # Install shell completions
    log_info "Installing shell completions..."
    install_completions
    
    echo ""
    echo "Next steps:"
    echo "  1. Add a profile: gh-switch add personal"
    echo "  2. Use profile: gh-switch use personal"
    echo ""
    echo "Note: Restart your shell or source your shell config to enable completions"
}

cmd_add() {
    local name="$1"
    [[ -z "$name" ]] && log_error "Usage: gh-switch add <profile-name>" && exit 1

    echo "Creating profile: ${name}"
    read -p "SSH key path (~/.ssh/): " ssh_key
    ssh_key="${ssh_key:-$HOME/.ssh/id_rsa}"
    read -p "Git name: " git_name
    read -p "Git email: " git_email
    read -p "GitHub username: " github_user

    local gpg_key="" gpg_sign="false"
    if check_gpg_installed; then
        echo ""
        log_info "GPG Signing Configuration (Optional)"
        echo "Would you like to configure GPG commit signing for this profile?"
        read -p "Configure GPG signing? (y/N): " configure_gpg
        if [[ "$configure_gpg" =~ ^[Yy]$ ]]; then
            gpg_key=$(select_gpg_key_interactive)
            if [[ -n "$gpg_key" ]]; then
                read -p "Enable GPG signing for all commits? (Y/n): " enable_signing
                [[ ! "$enable_signing" =~ ^[Nn]$ ]] && gpg_sign="true"
            fi
        fi
    fi

    create_profile "$name" "$ssh_key" "$git_name" "$git_email" "$github_user" "$gpg_key" "$gpg_sign"
    add_ssh_host "$name" "$ssh_key"

    log_success "Profile ${name} added successfully!"
    [[ -n "$gpg_key" ]] && log_info "GPG signing configured with key: ${gpg_key}"
    echo "Use 'gh-switch use ${name}' to activate"
}

cmd_use() {
    local profile_name="$1" scope="local"
    [[ -z "$profile_name" ]] && log_error "Usage: gh-switch use <profile> [--global]" && exit 1
    [[ "$2" == "--global" ]] && scope="global"

    load_profile "$profile_name" || (log_error "Profile '${profile_name}' not found" && exit 1)

    apply_git_profile "${GIT_NAME}" "${GIT_EMAIL}" "${scope}"
    apply_git_gpg_config "${GPG_KEY_ID}" "${GPG_SIGN_COMMITS}" "${scope}"
    echo "${profile_name}" > "${GH_SWITCH_DIR}/current"

    git rev-parse --git-dir &>/dev/null && update_remote_url "${profile_name}"
    log_success "Switched to profile: ${profile_name}"
}

cmd_current() {
    local current_file="${GH_SWITCH_DIR}/current"
    [[ ! -f "$current_file" ]] && echo "No profile currently active" && return

    local profile_name=$(cat "$current_file")
    if load_profile "$profile_name"; then
        echo -e "Current profile: ${GREEN}${profile_name}${NC}"
        echo "  Git user: ${GIT_NAME}"
        echo "  Git email: ${GIT_EMAIL}"
        echo "  GitHub user: ${GITHUB_USER}"
        
        if [[ -n "${GPG_KEY_ID:-}" ]]; then
            echo "  GPG key: ${GPG_KEY_ID}"
            [[ "${GPG_SIGN_COMMITS:-false}" == "true" ]] && echo "  GPG signing: Enabled" || echo "  GPG signing: Manual"
        fi

        if git rev-parse --git-dir &>/dev/null; then
            echo -e "\nRepository config:"
            echo "  user.name: $(get_git_config user.name)"
            echo "  user.email: $(get_git_config user.email)"
            local signing_key=$(get_git_config user.signingkey)
            local gpg_sign=$(get_git_config commit.gpgsign)
            [[ -n "$signing_key" ]] && echo "  user.signingkey: ${signing_key}"
            [[ -n "$gpg_sign" ]] && echo "  commit.gpgsign: ${gpg_sign}"
        fi
    else
        log_error "Current profile '${profile_name}' not found"
    fi
}

cmd_list() {
    ensure_config_dir
    local current_profile=""
    [[ -f "${GH_SWITCH_DIR}/current" ]] && current_profile=$(cat "${GH_SWITCH_DIR}/current")

    echo -e "Available profiles:\n=================="
    for profile_file in "${PROFILES_DIR}"/*; do
        if [[ -f "$profile_file" ]]; then
            local profile_name=$(basename "$profile_file")
            source "$profile_file"

            [[ "$profile_name" == "$current_profile" ]] && echo -e "${GREEN}* ${profile_name}${NC} (active)" || echo "  ${profile_name}"
            echo "    User: ${GIT_NAME}"
            echo "    Email: ${GIT_EMAIL}"
            if [[ -n "${GPG_KEY_ID:-}" ]]; then
                echo "    GPG Key: ${GPG_KEY_ID}"
                [[ "${GPG_SIGN_COMMITS:-false}" == "true" ]] && echo "    GPG Signing: Enabled" || echo "    GPG Signing: Manual"
            fi
            echo ""
        fi
    done
}

cmd_delete() {
    local profile_name="$1"
    [[ -z "$profile_name" ]] && log_error "Usage: gh-switch delete <profile>" && exit 1

    local profile_file="${PROFILES_DIR}/${profile_name}"
    [[ ! -f "$profile_file" ]] && log_error "Profile '${profile_name}' not found" && exit 1

    read -p "Delete profile '${profile_name}'? (y/n): " confirm
    [[ "$confirm" != "y" ]] && echo "Cancelled" && exit 0

    remove_ssh_host "github.com-${profile_name}"
    rm -f "$profile_file"

    if [[ -f "${GH_SWITCH_DIR}/current" ]]; then
        current=$(cat "${GH_SWITCH_DIR}/current")
        [[ "$current" == "$profile_name" ]] && rm -f "${GH_SWITCH_DIR}/current"
    fi

    log_success "Profile '${profile_name}' deleted"
}

cmd_auto() {
    if ! git rev-parse --git-dir &>/dev/null; then
        log_error "Not in a git repository"
        return 1
    fi

    local remote_url=$(git remote get-url origin 2>/dev/null)
    [[ -z "$remote_url" ]] && log_error "No origin remote found" && return 1

    if [[ "$remote_url" =~ github\.com-([a-z]+) ]]; then
        local detected="${BASH_REMATCH[1]}"
        log_info "Detected profile: ${detected}"
        cmd_use "$detected"
    else
        log_info "No profile detected for this repository"
    fi
}

cmd_help() {
    cat <<EOF
gh-switch - GitHub Account Switcher

USAGE:
    gh-switch <command> [options]

COMMANDS:
    init            Initialize gh-switch
    add <name>      Add a new profile
    use <name>      Switch to a profile
    current         Show current profile
    list            List all profiles
    delete <name>   Delete a profile
    auto            Auto-detect profile for current repo
    help            Show this help message

OPTIONS:
    --global        Apply profile globally (with 'use' command)

EXAMPLES:
    gh-switch init
    gh-switch add personal
    gh-switch use work
    gh-switch use personal --global

CONFIG:
    ~/.config/gh-switch/
EOF
}

# === Main ===
[[ "${1:-}" == "--version" ]] || [[ "${1:-}" == "-v" ]] && echo "gh-switch version ${VERSION}" && exit 0

ensure_config_dir

case "${1:-help}" in
    init|add|use|current|list|delete|auto|help)
        cmd="cmd_${1}"
        shift
        $cmd "$@"
        ;;
    *)
        cmd_help
        exit 1
        ;;
esac